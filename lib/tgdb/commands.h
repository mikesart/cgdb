#ifndef __COMMANDS_H__
#define __COMMANDS_H__

struct commands;

/**  
 * This should probably be moved out of a2-tgdb.h
 */
enum command_kind {
    /**
     * A custom command the user or gui requested.
     *
     * The commands package does not attempt to interpret the output
     * of this command for updates to cgdb.
     */
    COMMAND_USER_COMMAND,

    /**
	 * Get a list of breakpoints.
	 */
    COMMAND_BREAKPOINTS,

    /**
     * Tell gdb where to send inferior's output
	 */
    COMMAND_TTY,

    /**
     * Complete the current console line
	 */
    COMMAND_COMPLETE,

    /**
 	 * Show all the sources inferior is made of
	 */
    COMMAND_INFO_SOURCES,

    /**
 	 * Shows information on the current source file
	 */
    COMMAND_INFO_SOURCE,

    /**
     * Shows information on the current frame
     */
    COMMAND_INFO_FRAME,

    /**
     * Get disassembly for the $pc
     */
    COMMAND_DISASSEMBLE_PC,

    /**
     * Get disassembly for specified function
     */
    COMMAND_DISASSEMBLE_FUNC,

    /**
     * Get starting and ending addresses of the compiled code for source line location.
     */
    COMMAND_INFO_LINE,

    /**
     * Query if the CLI disassemble command supports mixed source+assembly.
     *
     * Mixed source+assembly mode was added as the /s flag to the CLI
     * disassemble command and as mode 4 to the MI -data-disassemble
     * command.
     *
     * We query the MI command to determine if it supports mode 4, and
     * if it does, we also know that teh cli disassemble command supports
     * /s.
     *
     * The passing case,
     *   (gdb) interpreter-exec mi "-data-disassemble -s 0 -e 0 -- 4"
     *   ^done,asm_insns=[]
     *
     * The failing case,
     *   (gdb) interpreter-exec mi "-data-disassemble -s 0 -e 0 -- 4"
     *   ^error,msg="-data-disassemble: Mode argument must be 0, 1, 2, or 3."
     *
     * If the command comes back as an MI error, we assume /s is not
     * supported.
     *
     * This functionality was added in gdb in commit 6ff0ba5f.
     */
    COMMAND_DATA_DISASSEMBLE_MODE_QUERY
};


/* commands_initialize: Initialize the commands unit */
struct commands *commands_initialize(struct tgdb *tgdb);
void commands_shutdown(struct commands *c);

/* commands_set_field_num: This is used for breakpoint annotations.
 *             field_num is the field that the breakpoint annotation is on.
 */
void commands_set_field_num(struct commands *c, int field_num);

/* runs a simple command, output goes to user  */
/*int commands_run_command(int fd, struct tgdb_client_command *com);*/

/* commands_issue_command:
 * -----------------------
 *  
 *  This is used by the annotations library to internally issure commands to
 *  the debugger. It sends a command to tgdb-base.
 *
 *  Returns -1 on error, 0 on success
 */
int commands_issue_command(struct commands *c,
    enum command_kind commmand_kind, const char *data, int oob);

/**
 * This function receives the output from gdb when gdb
 * is running a command on behalf of this package.
 *
 * @param c
 * The commands instance
 *
 * @param str
 * The string to process
 */
void commands_process(struct commands *c, const std::string &str);

/**
 * Called when a command produces an error.
 */
void commands_process_error(struct commands *c);

/* commands_prepare_for_command:
 * -----------------------------
 *
 *  Prepare's the client for the command COM to be run.
 *
 *  com:    The command to be run.
 */
void commands_prepare_for_command(struct commands *c, struct tgdb_command *com);

/* commands_user_ran_command:
 * --------------------------
 *
 * This lets the clients know that the user ran a command.
 * The client can update itself here if it need to.
 *
 * Returns: -1 on error, 0 on success
 */
int commands_user_ran_command(struct commands *c);

/**
 * The current command type. TGDB is capable of having any commands of this
 * type in it's queue.
 *
 * I don't know what this should look like completely.
 */
enum tgdb_command_choice {

    /**
     * A command from the front end
     */
    TGDB_COMMAND_FRONT_END,

    /** A command from the console */
    TGDB_COMMAND_CONSOLE,

    /** A command from a client of TGDB */
    TGDB_COMMAND_TGDB_CLIENT,

    /**
     * A priority command is a command that the client context needs
     * to run before it can finish getting the data necessary for a
     * TGDB_COMMAND_TGDB_CLIENT command.
     */
    TGDB_COMMAND_TGDB_CLIENT_PRIORITY
};

/* This is here to add new client_command/command faster */

/**
 * This is the main tgdb queue command.
 * It will be put into a queue and run.
 * For each TGDB command generated by a client, the client command is
 * with it.
 */
struct tgdb_command {
    /**
     * The actual command to give.
     */
    char *gdb_command;

    /**
     * The type of command this one is.
     */
    enum tgdb_command_choice command_choice;

    /** Private data the client context can use. */
    enum command_kind kind;
};

/**
 * Creates a new command and initializes it
 *
 * \param tgdb_command_data
 * The data needed to run the command
 *
 * \param command_choice
 * The type of command to run.
 *
 * \param action_choice
 * The type of action TGDB would like to perform.
 *
 * \param client_data
 * Data that the client can use when prepare_client_for_command is called
 *
 * @return
 * Always is successful, will call exit on failed malloc
 */
struct tgdb_command *tgdb_command_create(const char *tgdb_command_data,
        enum tgdb_command_choice command_choice, enum command_kind kind);

/**
 * This will free a TGDB queue command.
 * These are the commands given by TGDB to the debugger.
 * This is a function for debugging.
 *
 * \param item
 * The tgdb_command to free
 */
void tgdb_command_destroy(struct tgdb_command *tc);

/**
 * Return if the debugger supports the /s flag for the disassemble command.
 *
 * @return
 * 0 if /s is not supported, 1 if it is supported.
 */
int commands_disassemble_supports_s_mode(struct commands *c);

bool commands_is_console_command(struct commands *c);

/**
 * Add a tgdb response.
 *
 * @param c
 * The commands instance
 *
 * @param response
 * The response to add
 */
void commands_add_response(struct commands *c, struct tgdb_response *response);

/**
 * Delete all the tgdb responses associated with this commands instance.
 *
 * @param c
 * The commands instance
 */
void commands_delete_responses(struct commands *c);

/**
 * Get the tgdb responses for the given index.
 *
 * @param c
 * The commands instance
 *
 * @param index
 * The response index to get. Start at 0 and move up until NULL is returned.
 */
struct tgdb_response *commands_get_response(struct commands *c, int index);

#endif /* __COMMANDS_H__ */
